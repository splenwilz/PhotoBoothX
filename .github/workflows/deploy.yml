name: "Build and Deploy PhotoBoothX"

on:
  push:
    branches:
      - '**'  # Run on all branches
  pull_request:
    branches:
      - '**'  # Run on PRs to any branch
  release:
    types: [published]

# Add permissions for GitHub token
permissions:
  contents: write
  actions: read
  checks: write

env:
  DOTNET_VERSION: '8.0.x'
  PROJECT_PATH: 'PhotoBooth/PhotoBooth.csproj'
  INSTALLER_PATH: 'installer/PhotoBoothX.iss'
  PUBLISH_PATH: 'PhotoBooth/bin/Release/net8.0-windows/win-x64/publish'

jobs:
  # Quick test job that runs on every commit
  test-only:
    name: Run Tests
    runs-on: windows-latest
    # Skip this job if we're doing a full build (production/main/master/test)
    if: github.ref != 'refs/heads/production' && github.ref != 'refs/heads/main' && github.ref != 'refs/heads/master' && github.ref != 'refs/heads/test'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
          
    - name: Restore dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }}
      
    - name: Build application (Debug)
      run: dotnet build ${{ env.PROJECT_PATH }} --configuration Debug --no-restore
      
    - name: Run tests
      run: |
        if (Test-Path "Photobooth.Tests/Photobooth.Tests.csproj") {
          Write-Host "[TEST] Running PhotoBoothX tests..."
          dotnet test Photobooth.Tests/Photobooth.Tests.csproj --configuration Debug --no-build --verbosity normal --logger "console;verbosity=detailed"
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[OK] All tests passed!" -ForegroundColor Green
          } else {
            Write-Host "[ERROR] Some tests failed!" -ForegroundColor Red
            exit 1
          }
        } else {
          Write-Host "[WARNING] No tests found, skipping test execution" -ForegroundColor Yellow
        }
      shell: powershell

  # Full build and test job (production/main/master only)
  build-and-test:
    name: Build and Test (Full)
    runs-on: windows-latest
    # Only run on production/main/master/test branches or release events
    if: github.ref == 'refs/heads/production' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test' || github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Needed for version calculation
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
          
    - name: Restore dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }}
      
    # Inject master password config if GitHub secret exists
    # This enables the feature for official releases while keeping forks/self-hosted simple
    - name: Create master password config (if secret available)
      run: |
        if ("${{ secrets.MASTER_PASSWORD_BASE_SECRET }}" -eq "") {
          Write-Host "[WARNING] No MASTER_PASSWORD_BASE_SECRET found" -ForegroundColor Yellow
          Write-Host "   Master password feature will be DISABLED" -ForegroundColor Yellow
          Write-Host "   (This is normal for forks and self-hosted builds)" -ForegroundColor Cyan
        } else {
          $config = @"
        {
          \"version\": \"1.0\",
          \"encrypted\": false,
          \"baseSecret\": \"${{ secrets.MASTER_PASSWORD_BASE_SECRET }}\"
        }
        "@
          $config | Out-File -FilePath "PhotoBooth/master-password.config" -Encoding UTF8
          Write-Host "[OK] Master password config created" -ForegroundColor Green
          Write-Host "   Master password feature will be ENABLED" -ForegroundColor Green
        }
      shell: powershell
      
    - name: Build application
      run: dotnet build ${{ env.PROJECT_PATH }} --configuration Release --no-restore
      
    - name: Verify build configuration
      run: |
        if (Test-Path "PhotoBooth/master-password.config") {
          Write-Host "[OK] Master password feature ENABLED" -ForegroundColor Green
          Write-Host "     Config file detected and will be included in build" -ForegroundColor Cyan
        } else {
          Write-Host "[INFO] Master password feature DISABLED" -ForegroundColor Yellow
          Write-Host "       Building without config file (feature optional)" -ForegroundColor Cyan
        }
      shell: powershell
      
    - name: Run tests with coverage
      run: |
        if (Test-Path "Photobooth.Tests/Photobooth.Tests.csproj") {
          Write-Host "[TEST] Running PhotoBoothX tests with coverage..."
          dotnet test Photobooth.Tests/Photobooth.Tests.csproj --configuration Release --no-build --verbosity normal --collect:"XPlat Code Coverage" --logger trx --results-directory coverage
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[OK] All tests passed!" -ForegroundColor Green
          } else {
            Write-Host "[ERROR] Some tests failed!" -ForegroundColor Red
            exit 1
          }
        } else {
          Write-Host "[WARNING] No tests found, skipping test execution" -ForegroundColor Yellow
        }
      shell: powershell
      
    - name: Publish application
      run: dotnet publish ${{ env.PROJECT_PATH }} --configuration Release --output ${{ env.PUBLISH_PATH }} --self-contained true --runtime win-x64 /p:PublishSingleFile=true /p:PublishReadyToRun=true
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: published-app
        path: ${{ env.PUBLISH_PATH }}
        retention-days: 7

  create-installer:
    name: Create Installer
    needs: build-and-test
    runs-on: windows-latest
    if: github.ref == 'refs/heads/production' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test' || github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: published-app
        path: ${{ env.PUBLISH_PATH }}
        
    # Re-inject master password config if GitHub secret available
    # (config file must be in source directory for Inno Setup to include it)
    - name: Add master password config to installer (if secret available)
      run: |
        if ("${{ secrets.MASTER_PASSWORD_BASE_SECRET }}" -ne "") {
          $config = @"
        {
          \"version\": \"1.0\",
          \"encrypted\": false,
          \"baseSecret\": \"${{ secrets.MASTER_PASSWORD_BASE_SECRET }}\"
        }
        "@
          # Create config in the source directory (for Inno Setup to find)
          $config | Out-File -FilePath "PhotoBooth/master-password.config" -Encoding UTF8
          Write-Host "[OK] Master password config added to installer package" -ForegroundColor Green
        } else {
          Write-Host "[INFO]  No master password secret available" -ForegroundColor Yellow
        }
      shell: powershell
        
    - name: Setup Inno Setup
      uses: crazy-max/ghaction-chocolatey@v3
      with:
        args: install innosetup -y
        
    - name: Verify Inno Setup Installation
      run: |
        # Check if Inno Setup was installed successfully
        $isccPaths = @(
          "C:\Program Files (x86)\Inno Setup 6\ISCC.exe",
          "C:\Program Files\Inno Setup 6\ISCC.exe",
          "C:\tools\innosetup\ISCC.exe"
        )
        
        $isccPath = $null
        foreach ($path in $isccPaths) {
          if (Test-Path $path) {
            $isccPath = $path
            Write-Host "[OK] Found ISCC.exe at: $path"
            break
          }
        }
        
        if (-not $isccPath) {
          Write-Host "[ERROR] ISCC.exe not found in expected locations"
          Write-Host "Searching for ISCC.exe..."
          Get-ChildItem "C:\" -Recurse -Name "ISCC.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Found: $_"
          }
          throw "Inno Setup not found"
        }
      shell: powershell
        
    - name: Get version from project
      id: get_version
      run: |
        $xml = [xml](Get-Content ${{ env.PROJECT_PATH }})
        $version = $xml.Project.PropertyGroup.Version
        if (-not $version) {
          $version = "1.0.0"
        }
        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        echo "Version: $version"
      shell: powershell
      
    - name: Update installer version
      run: |
        $version = "${{ steps.get_version.outputs.VERSION }}"
        $installerContent = Get-Content ${{ env.INSTALLER_PATH }} -Raw
        $installerContent = $installerContent -replace '#define MyAppVersion ".*"', "#define MyAppVersion `"$version`""
        Set-Content ${{ env.INSTALLER_PATH }} -Value $installerContent
      shell: powershell
      
    - name: Create dist directory
      run: New-Item -ItemType Directory -Force -Path "dist"
      shell: powershell
      
    - name: Build installer
      run: |
        # Try multiple possible paths for Inno Setup
        $isccPaths = @(
          "C:\Program Files (x86)\Inno Setup 6\ISCC.exe",
          "C:\Program Files\Inno Setup 6\ISCC.exe",
          "C:\tools\Inno Setup 6\ISCC.exe"
        )
        
        $isccPath = $null
        foreach ($path in $isccPaths) {
          if (Test-Path $path) {
            $isccPath = $path
            Write-Host "Found ISCC.exe at: $path"
            break
          }
        }
        
        if (-not $isccPath) {
          Write-Host "Searching for ISCC.exe in all Program Files directories..."
          Get-ChildItem -Path "C:\Program Files*" -Recurse -Name "ISCC.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Found: $_"
          }
          throw "ISCC.exe not found"
        }
        
        # Verify installer script exists
        $installerScript = "${{ env.INSTALLER_PATH }}"
        if (-not (Test-Path $installerScript)) {
          throw "Installer script not found: $installerScript"
        }
        
        Write-Host "Building installer with: $isccPath"
        Write-Host "Installer script: $installerScript"
        
        # Run the compiler and capture output
        try {
          $output = & $isccPath $installerScript 2>&1
          Write-Host "Compiler output:"
          $output | ForEach-Object { Write-Host "  $_" }
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Exit code: $LASTEXITCODE"
            throw "Installer build failed with exit code $LASTEXITCODE"
          }
          
          Write-Host "[OK] Installer built successfully"
        } catch {
          Write-Host "[ERROR] Error during compilation:"
          Write-Host $_.Exception.Message
          throw
        }
      shell: powershell
      
    - name: Add environment suffix to installer
      run: |
        $installerFiles = Get-ChildItem -Path "dist" -Filter "*.exe"
        if ($installerFiles.Count -eq 0) {
          Write-Host "[ERROR] No installer file found in dist directory" -ForegroundColor Red
          throw "Installer file not found"
        }
        
        # Determine environment based on branch
        $branch = "${{ github.ref }}"
        $suffix = ""
        
        if ($branch -eq "refs/heads/production") {
          $suffix = "" # Production has no suffix
          Write-Host "[BUILD] Environment: Production (stable release)" -ForegroundColor Green
        } elseif ($branch -eq "refs/heads/test") {
          $suffix = "-Test"
          Write-Host "[BUILD] Environment: Test (release testing)" -ForegroundColor Magenta
        } elseif ($branch -eq "refs/heads/master" -or $branch -eq "refs/heads/main") {
          $suffix = "-Staging"
          Write-Host "[BUILD] Environment: Staging (pre-release testing)" -ForegroundColor Yellow
        } elseif ($branch -match "refs/tags/(.+)") {
          # Release tags: check if it's a pre-release
          if ($branch -match "alpha|beta|rc|staging|test") {
            $suffix = "-Staging"
            Write-Host "[BUILD] Environment: Staging (pre-release tag)" -ForegroundColor Yellow
          } else {
            $suffix = "" # Stable release tag
            Write-Host "[BUILD] Environment: Production (release tag)" -ForegroundColor Green
          }
        } else {
          $suffix = "-Dev"
          Write-Host "[BUILD] Environment: Development (other branch)" -ForegroundColor Cyan
        }
        
        foreach ($file in $installerFiles) {
          if ($suffix -ne "") {
            $originalName = $file.Name
            $newName = $originalName -replace "\.exe$", "$suffix.exe"
            
            $sourcePath = $file.FullName
            $destPath = Join-Path "dist" $newName
            
            Move-Item -Path $sourcePath -Destination $destPath -Force
            Write-Host "[OK] Renamed: $originalName → $newName" -ForegroundColor Green
          } else {
            Write-Host "[OK] Keeping original name: $($file.Name)" -ForegroundColor Green
          }
        }
      shell: powershell
      
    - name: Upload installer artifact
      uses: actions/upload-artifact@v4
      with:
        name: installer
        path: dist/*.exe
        retention-days: 7
        
    - name: List installer files
      run: Get-ChildItem -Path "dist" -Recurse
      shell: powershell

  create-release:
    name: Create GitHub Release
    needs: [build-and-test, create-installer]
    runs-on: windows-latest
    if: github.ref == 'refs/heads/production' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Get version from project
      id: get_version
      run: |
        $xml = [xml](Get-Content ${{ env.PROJECT_PATH }})
        $version = $xml.Project.PropertyGroup.Version
        if (-not $version) {
          $version = "1.0.0"
        }
        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        echo "RELEASE_TAG=v$version" >> $env:GITHUB_OUTPUT
      shell: powershell
      
    - name: Download installer artifact
      uses: actions/download-artifact@v4
      with:
        name: installer
        path: installer-files
        
    - name: Generate release notes
      id: release_notes
      run: |
        $releaseNotes = @"
        ## PhotoBoothX Release ${{ steps.get_version.outputs.VERSION }}
        
        ### 🔐 Security Features
        - **PIN-Based Password Recovery** - Secure 4-digit PIN system for password resets
        - **Mandatory PIN Setup** - Admins must set recovery PIN after first login
        - **Forgot Password Flow** - User-friendly recovery process with account selection
        - **Rate Limiting Protection** - 5 attempts with 1-minute lockout prevents brute force
        - **Enhanced Password Policy** - Enforced strong passwords (8+ chars, uppercase, lowercase, number)
        - **Kiosk-Friendly Virtual Keyboard** - Touch-screen compatible PIN and password entry
        
        ### ✨ What's New
        - Complete offline password recovery system (no email/SMS required)
        - Improved admin security with forced password changes on first login
        - Modern, glassy UI design for PIN recovery and password reset screens
        - Comprehensive test coverage (92.4% for recovery features)
        - Enhanced audit logging for security events
        - Professional installer with auto-launch support
        
        ### 🛠️ Technical Improvements
        - PBKDF2-SHA256 encryption with 100,000 iterations for PIN storage
        - Constant-time comparison to prevent timing attacks
        - Secure password validation with centralized policy service
        - Virtual keyboard integration for kiosk environments
        - Timer-based lockout with automatic recovery
        
        ### [BUILD] Installation
        1. Download PhotoBoothX-Setup-${{ steps.get_version.outputs.VERSION }}.exe
        2. Run as Administrator
        3. Follow the installation wizard
        4. The application will auto-launch on Windows startup (recommended for kiosk mode)
        5. Set your recovery PIN after first login (required for password recovery)
        
        ### 💻 System Requirements
        - Windows 10/11 (64-bit)
        - .NET 8.0 Runtime (included in installer)
        - Administrator privileges for installation
        - USB ports for camera and hardware
        - Touch screen (optional - for virtual keyboard)
        
        ### 📝 Important Notes
        - **First Login**: Default credentials remain admin/admin123 - you'll be forced to change
        - **PIN Setup**: Mandatory after first login - enables password recovery
        - **Forgot Password**: Available from login screen - requires account selection and PIN
        - **Password Reset**: Strong password requirements enforced (8+ chars, mixed case, number)
        - **Database**: Stored in AppData (survives reinstalls, includes PIN data)
        - **Templates**: User-updatable in Program Files
        - **Rate Limiting**: 1-minute lockout after 5 failed PIN attempts
        
        ### 🔒 Security Best Practices
        - Change default password immediately on first login
        - Set up recovery PIN (required for password recovery)
        - Use strong passwords with mixed case and numbers
        - Keep recovery PIN secure and memorable
        - Monitor audit logs for security events
        
        ---
        **Build:** ${{ github.sha }}  
        **Date:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')  
        **Test Coverage:** 92.4% (PIN Recovery), 63 tests passing
        "@
        
        $releaseNotes | Out-File -FilePath release_notes.txt -Encoding utf8
        echo "RELEASE_BODY<<EOF" >> $env:GITHUB_OUTPUT
        Get-Content release_notes.txt | ForEach-Object { echo $_ >> $env:GITHUB_OUTPUT }
        echo "EOF" >> $env:GITHUB_OUTPUT
      shell: powershell
      
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.get_version.outputs.RELEASE_TAG }}
        name: PhotoBoothX ${{ steps.get_version.outputs.VERSION }}
        body: ${{ steps.release_notes.outputs.RELEASE_BODY }}
        draft: false
        prerelease: false
        files: |
          installer-files/*.exe
        make_latest: true
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notify-success:
    name: Notify Deployment Success
    needs: [create-release]
    runs-on: windows-latest
    if: success() && (github.ref == 'refs/heads/production' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test')
    
    steps:
    - name: Success notification
      run: |
        Write-Host "[SUCCESS] PhotoBoothX deployment successful!"
        Write-Host "[BUILD] Installer available in GitHub Releases"
        Write-Host "[LINK] Your client can download from: ${{ github.server_url }}/${{ github.repository }}/releases/latest"
      shell: powershell