name: "Build and Deploy PhotoBoothX"

on:
  push:
    branches:
      - '**'  # Run on all branches
  pull_request:
    branches:
      - '**'  # Run on PRs to any branch
  release:
    types: [published]

# Add permissions for GitHub token
permissions:
  contents: write
  actions: read
  checks: write

env:
  DOTNET_VERSION: '8.0.x'
  PROJECT_PATH: 'PhotoBooth/PhotoBooth.csproj'
  INSTALLER_PATH: 'installer/PhotoBoothX.iss'
  PUBLISH_PATH: 'PhotoBooth/bin/Release/net8.0-windows/win-x64/publish'

jobs:
  # Quick test job that runs on every commit
  test-only:
    name: Run Tests
    runs-on: windows-latest
    # Skip this job if we're doing a full build (production/main/master/test)
    if: github.ref != 'refs/heads/production' && github.ref != 'refs/heads/main' && github.ref != 'refs/heads/master' && github.ref != 'refs/heads/test'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
          
    - name: Restore dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }}
      
    - name: Build application (Debug)
      run: dotnet build ${{ env.PROJECT_PATH }} --configuration Debug --no-restore
      
    - name: Run tests
      run: |
        if (Test-Path "Photobooth.Tests/Photobooth.Tests.csproj") {
          Write-Host "[TEST] Running PhotoBoothX tests..."
          dotnet test Photobooth.Tests/Photobooth.Tests.csproj --configuration Debug --no-build --verbosity normal --logger "console;verbosity=detailed"
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[OK] All tests passed!" -ForegroundColor Green
          } else {
            Write-Host "[ERROR] Some tests failed!" -ForegroundColor Red
            exit 1
          }
        } else {
          Write-Host "[WARNING] No tests found, skipping test execution" -ForegroundColor Yellow
        }
      shell: powershell

  # Full build and test job (production/main/master only)
  build-and-test:
    name: Build and Test (Full)
    runs-on: windows-latest
    # Only run on production/main/master/test branches or release events
    if: github.ref == 'refs/heads/production' || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test' || github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Needed for version calculation
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
          
    - name: Restore dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }}
      
    # Inject master password config if GitHub secret exists
    # This enables the feature for official releases while keeping forks/self-hosted simple
    - name: Create master password config (if secret available)
      run: |
        if ("${{ secrets.MASTER_PASSWORD_BASE_SECRET }}" -eq "") {
          Write-Host "[WARNING] No MASTER_PASSWORD_BASE_SECRET found" -ForegroundColor Yellow
          Write-Host "   Master password feature will be DISABLED" -ForegroundColor Yellow
          Write-Host "   (This is normal for forks and self-hosted builds)" -ForegroundColor Cyan
        } else {
          $json = @{
            version = "1.0"
            encrypted = $false
            baseSecret = "${{ secrets.MASTER_PASSWORD_BASE_SECRET }}"
          }
          $json | ConvertTo-Json | Out-File -FilePath "PhotoBooth/master-password.config" -Encoding UTF8
          Write-Host "[OK] Master password config created" -ForegroundColor Green
          Write-Host "   Master password feature will be ENABLED" -ForegroundColor Green
        }
      shell: powershell
      
    - name: Build application
      run: dotnet build ${{ env.PROJECT_PATH }} --configuration Release --no-restore
      
    - name: Verify build configuration
      run: |
        if (Test-Path "PhotoBooth/master-password.config") {
          Write-Host "[OK] Master password feature ENABLED" -ForegroundColor Green
          Write-Host "     Config file detected and will be included in build" -ForegroundColor Cyan
        } else {
          Write-Host "[INFO] Master password feature DISABLED" -ForegroundColor Yellow
          Write-Host "       Building without config file (feature optional)" -ForegroundColor Cyan
        }
      shell: powershell
      
    - name: Run tests with coverage
      run: |
        if (Test-Path "Photobooth.Tests/Photobooth.Tests.csproj") {
          Write-Host "[TEST] Running PhotoBoothX tests with coverage..."
          dotnet test Photobooth.Tests/Photobooth.Tests.csproj --configuration Release --no-build --verbosity normal --collect:"XPlat Code Coverage" --logger trx --results-directory coverage
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[OK] All tests passed!" -ForegroundColor Green
          } else {
            Write-Host "[ERROR] Some tests failed!" -ForegroundColor Red
            exit 1
          }
        } else {
          Write-Host "[WARNING] No tests found, skipping test execution" -ForegroundColor Yellow
        }
      shell: powershell
      
    - name: Publish application
      run: dotnet publish ${{ env.PROJECT_PATH }} --configuration Release --output ${{ env.PUBLISH_PATH }} --self-contained true --runtime win-x64 /p:PublishSingleFile=true /p:PublishReadyToRun=true
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: published-app
        path: ${{ env.PUBLISH_PATH }}
        retention-days: 7

  create-installer:
    name: Create Installer
    needs: build-and-test
    runs-on: windows-latest
    if: github.ref == 'refs/heads/production' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test' || github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: published-app
        path: ${{ env.PUBLISH_PATH }}
        
    # Re-inject master password config if GitHub secret available
    # (config file must be in source directory for Inno Setup to include it)
    - name: Add master password config to installer (if secret available)
      run: |
        if ("${{ secrets.MASTER_PASSWORD_BASE_SECRET }}" -ne "") {
          $json = @{
            version = "1.0"
            encrypted = $false
            baseSecret = "${{ secrets.MASTER_PASSWORD_BASE_SECRET }}"
          }
          # Create config in the source directory (for Inno Setup to find)
          $json | ConvertTo-Json | Out-File -FilePath "PhotoBooth/master-password.config" -Encoding UTF8
          Write-Host "[OK] Master password config added to installer package" -ForegroundColor Green
        } else {
          Write-Host "[INFO]  No master password secret available" -ForegroundColor Yellow
        }
      shell: powershell
        
    - name: Setup Inno Setup
      uses: crazy-max/ghaction-chocolatey@v3
      with:
        args: install innosetup -y
        
    - name: Verify Inno Setup Installation
      run: |
        # Check if Inno Setup was installed successfully
        $isccPaths = @(
          "C:\Program Files (x86)\Inno Setup 6\ISCC.exe",
          "C:\Program Files\Inno Setup 6\ISCC.exe",
          "C:\tools\innosetup\ISCC.exe"
        )
        
        $isccPath = $null
        foreach ($path in $isccPaths) {
          if (Test-Path $path) {
            $isccPath = $path
            Write-Host "[OK] Found ISCC.exe at: $path"
            break
          }
        }
        
        if (-not $isccPath) {
          Write-Host "[ERROR] ISCC.exe not found in expected locations"
          Write-Host "Searching for ISCC.exe..."
          Get-ChildItem "C:\" -Recurse -Name "ISCC.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Found: $_"
          }
          throw "Inno Setup not found"
        }
      shell: powershell
        
    - name: Get version from project
      id: get_version
      run: |
        $xml = [xml](Get-Content ${{ env.PROJECT_PATH }})
        $version = $xml.Project.PropertyGroup.Version
        if (-not $version) {
          $version = "1.0.0"
        }
        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        echo "Version: $version"
      shell: powershell
      
    - name: Update installer version
      run: |
        $version = "${{ steps.get_version.outputs.VERSION }}"
        $installerContent = Get-Content ${{ env.INSTALLER_PATH }} -Raw
        $installerContent = $installerContent -replace '#define MyAppVersion ".*"', "#define MyAppVersion `"$version`""
        Set-Content ${{ env.INSTALLER_PATH }} -Value $installerContent
      shell: powershell
      
    - name: Create dist directory
      run: New-Item -ItemType Directory -Force -Path "dist"
      shell: powershell
      
    - name: Build installer
      run: |
        # Try multiple possible paths for Inno Setup
        $isccPaths = @(
          "C:\Program Files (x86)\Inno Setup 6\ISCC.exe",
          "C:\Program Files\Inno Setup 6\ISCC.exe",
          "C:\tools\Inno Setup 6\ISCC.exe"
        )
        
        $isccPath = $null
        foreach ($path in $isccPaths) {
          if (Test-Path $path) {
            $isccPath = $path
            Write-Host "Found ISCC.exe at: $path"
            break
          }
        }
        
        if (-not $isccPath) {
          Write-Host "Searching for ISCC.exe in all Program Files directories..."
          Get-ChildItem -Path "C:\Program Files*" -Recurse -Name "ISCC.exe" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Found: $_"
          }
          throw "ISCC.exe not found"
        }
        
        # Verify installer script exists
        $installerScript = "${{ env.INSTALLER_PATH }}"
        if (-not (Test-Path $installerScript)) {
          throw "Installer script not found: $installerScript"
        }
        
        Write-Host "Building installer with: $isccPath"
        Write-Host "Installer script: $installerScript"
        
        # Run the compiler and capture output
        try {
          $output = & $isccPath $installerScript 2>&1
          Write-Host "Compiler output:"
          $output | ForEach-Object { Write-Host "  $_" }
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Exit code: $LASTEXITCODE"
            throw "Installer build failed with exit code $LASTEXITCODE"
          }
          
          Write-Host "[OK] Installer built successfully"
        } catch {
          Write-Host "[ERROR] Error during compilation:"
          Write-Host $_.Exception.Message
          throw
        }
      shell: powershell
      
    - name: Add environment suffix to installer
      run: |
        $installerFiles = Get-ChildItem -Path "dist" -Filter "*.exe"
        if ($installerFiles.Count -eq 0) {
          Write-Host "[ERROR] No installer file found in dist directory" -ForegroundColor Red
          throw "Installer file not found"
        }
        
        # Determine environment based on branch
        $branch = "${{ github.ref }}"
        $suffix = ""
        
        if ($branch -eq "refs/heads/production") {
          $suffix = "" # Production has no suffix
          Write-Host "[BUILD] Environment: Production (stable release)" -ForegroundColor Green
        } elseif ($branch -eq "refs/heads/test") {
          $suffix = "-Test"
          Write-Host "[BUILD] Environment: Test (release testing)" -ForegroundColor Magenta
        } elseif ($branch -eq "refs/heads/master" -or $branch -eq "refs/heads/main") {
          $suffix = "-Staging"
          Write-Host "[BUILD] Environment: Staging (pre-release testing)" -ForegroundColor Yellow
        } elseif ($branch -match "refs/tags/(.+)") {
          # Release tags: check if it's a pre-release
          if ($branch -match "alpha|beta|rc|staging|test") {
            $suffix = "-Staging"
            Write-Host "[BUILD] Environment: Staging (pre-release tag)" -ForegroundColor Yellow
          } else {
            $suffix = "" # Stable release tag
            Write-Host "[BUILD] Environment: Production (release tag)" -ForegroundColor Green
          }
        } else {
          $suffix = "-Dev"
          Write-Host "[BUILD] Environment: Development (other branch)" -ForegroundColor Cyan
        }
        
        foreach ($file in $installerFiles) {
          if ($suffix -ne "") {
            $originalName = $file.Name
            $newName = $originalName -replace "\.exe$", "$suffix.exe"
            
            $sourcePath = $file.FullName
            $destPath = Join-Path "dist" $newName
            
            Move-Item -Path $sourcePath -Destination $destPath -Force
            Write-Host "[OK] Renamed: $originalName → $newName" -ForegroundColor Green
          } else {
            Write-Host "[OK] Keeping original name: $($file.Name)" -ForegroundColor Green
          }
        }
      shell: powershell
      
    - name: Upload installer artifact
      uses: actions/upload-artifact@v4
      with:
        name: installer
        path: dist/*.exe
        retention-days: 7
        
    - name: List installer files
      run: Get-ChildItem -Path "dist" -Recurse
      shell: powershell

  create-release:
    name: Create GitHub Release
    needs: [build-and-test, create-installer]
    runs-on: windows-latest
    if: github.ref == 'refs/heads/production' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Get version from project
      id: get_version
      run: |
        $xml = [xml](Get-Content ${{ env.PROJECT_PATH }})
        $version = $xml.Project.PropertyGroup.Version
        if (-not $version) {
          $version = "1.0.0"
        }
        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        echo "RELEASE_TAG=v$version" >> $env:GITHUB_OUTPUT
      shell: powershell
      
    - name: Download installer artifact
      uses: actions/download-artifact@v4
      with:
        name: installer
        path: installer-files
        
    - name: Generate release notes
      id: release_notes
      run: |
        $version = "${{ steps.get_version.outputs.VERSION }}"
        $date = Get-Date -Format "yyyy-MM-dd"
        $branch = "${{ github.ref }}"
        
        # Determine release type
        $releaseType = "Stable"
        if ($branch -eq "refs/heads/test") {
          $releaseType = "Test"
        } elseif ($branch -eq "refs/heads/master" -or $branch -eq "refs/heads/main") {
          $releaseType = "Staging"
        }
        
        $releaseNotes = @"
        ## $date, Version $version ($releaseType)
        
        ### Notable Changes
        
        #### Master Password System (Enterprise Feature)
        - Offline master password generation and validation using HMAC-SHA256
        - Machine-specific key derivation with PBKDF2 (100,000 iterations)
        - Single-use passwords with cryptographic nonce for replay attack prevention
        - Windows DPAPI encryption for secure key storage
        - Rate limiting (5 attempts, 1-minute lockout) to prevent brute force attacks
        - Automatic config file deletion after first use for enhanced security
        - Full audit logging of all master password usage and failed attempts
        - TypeScript/Next.js support tool for password generation by support teams
        
        #### Security Enhancements
        - PIN-based password recovery system for offline admin access
        - Mandatory PIN setup after first login for all admin accounts
        - Enhanced password policy enforcement (8+ characters, mixed case, numbers)
        - PBKDF2-SHA256 encryption for PIN storage with constant-time comparison
        - Embedded database schema as resource to prevent tampering
        - Debug symbols removed from release builds
        - Virtual keyboard integration for kiosk touch-screen environments
        
        #### System Improvements
        - SQLite database with foreign key constraint enforcement
        - Improved error handling and logging throughout the application
        - Template synchronization on startup for immediate availability
        - Professional installer with automatic cleanup and uninstall support
        
        ### Installation
        
        1. Download the installer: \`PhotoBoothX-Setup-$version.exe\`
        2. Run as Administrator
        3. Follow the installation wizard
        4. Launch the application (auto-starts on Windows startup in kiosk mode)
        5. Login with default credentials: \`admin\` / \`admin123\`
        6. Set your recovery PIN when prompted (required)
        
        ### System Requirements
        
        - **OS**: Windows 10/11 (64-bit)
        - **Runtime**: .NET 8.0 (included in installer)
        - **Privileges**: Administrator access for installation
        - **Hardware**: USB ports for camera and peripherals
        - **Optional**: Touch screen for virtual keyboard
        
        ### Security Notes
        
        - Change default password immediately after first login
        - Set up recovery PIN (mandatory for password recovery)
        - Master password feature available in enterprise installations only
        - Database stored in AppData, survives reinstalls
        - All security events logged for audit purposes
        
        ### Documentation
        
        - [Security Hardening Guide](https://github.com/${{ github.repository }}/blob/master/docs/SECURITY_HARDENING.md)
        - [Master Password Setup](https://github.com/${{ github.repository }}/blob/master/PhotoBooth/docs/MasterPasswordSetup.md)
        - [Deployment Guide](https://github.com/${{ github.repository }}/blob/master/docs/deployment.md)
        
        ---
        
        **Commit**: ${{ github.sha }}  
        **Build Date**: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')  
        **Test Coverage**: 92.4% (63 tests passing)
        "@
        
        $releaseNotes | Out-File -FilePath release_notes.txt -Encoding utf8
        echo "RELEASE_BODY<<EOF" >> $env:GITHUB_OUTPUT
        Get-Content release_notes.txt | ForEach-Object { echo $_ >> $env:GITHUB_OUTPUT }
        echo "EOF" >> $env:GITHUB_OUTPUT
      shell: powershell
      
    - name: Determine release settings
      id: release_settings
      run: |
        $branch = "${{ github.ref }}"
        $version = "${{ steps.get_version.outputs.VERSION }}"
        
        # Determine if this is a prerelease and tag suffix
        if ($branch -eq "refs/heads/test") {
          "PRERELEASE=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "TAG_SUFFIX=-test" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "MAKE_LATEST=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        } elseif ($branch -eq "refs/heads/master" -or $branch -eq "refs/heads/main") {
          "PRERELEASE=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "TAG_SUFFIX=-staging" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "MAKE_LATEST=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        } else {
          # production branch
          "PRERELEASE=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "TAG_SUFFIX=" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "MAKE_LATEST=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        }
      shell: powershell
      
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.get_version.outputs.RELEASE_TAG }}${{ steps.release_settings.outputs.TAG_SUFFIX }}
        name: ${{ steps.get_version.outputs.VERSION }}${{ steps.release_settings.outputs.TAG_SUFFIX }}
        body: ${{ steps.release_notes.outputs.RELEASE_BODY }}
        draft: false
        prerelease: ${{ steps.release_settings.outputs.PRERELEASE }}
        files: |
          installer-files/*.exe
        make_latest: ${{ steps.release_settings.outputs.MAKE_LATEST }}
        generate_release_notes: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  notify-success:
    name: Notify Deployment Success
    needs: [create-release]
    runs-on: windows-latest
    if: success() && (github.ref == 'refs/heads/production' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/test')
    
    steps:
    - name: Success notification
      run: |
        Write-Host "[SUCCESS] PhotoBoothX deployment successful!"
        Write-Host "[BUILD] Installer available in GitHub Releases"
        Write-Host "[LINK] Your client can download from: ${{ github.server_url }}/${{ github.repository }}/releases/latest"
      shell: powershell